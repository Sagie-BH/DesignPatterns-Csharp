SOLID design principles in C# are basic design principles. 


In Object Oriented Programming (OOP), SOLID is an acronym, introduced by Michael Feathers, for five design principles used to make software design more understandable, flexible, and maintainable. These principles are a subset of many principles promoted by Robert C. Martin.
SOLID Principles


There are five SOLID principles:

Single Responsibility Principle (SRP)
Open Closed Principle (OCP)
Liskov Substitution Principle (LSP)
Interface Segregation Principle (ISP)
Dependency Inversion Principle (DIP)


Single Responsibility Principle (SRP)

כל מחלקה צריכה להיות אחראית על חלק בודד של הפונקציונליות המסופקת על ידי התוכנה, האחריות הזאת צריכה להיות מובלעת encapsulated על ידי אותה מחלקה.
המטרה העיקרית של עיקרון זה היא הפחתת המורכבות. אנחנו לא צריכים להמציא עיצוב מתוחכם לתוכנית שיש בה רק כ-200 שורות קוד. 10 שיטות יפות, ואנחנו נהיה בסדר.
הבעיות האמיתיות מתעוררות כאשר התוכנית שלנו כל הזמן גדלה ומשתנה.
בשלב מסוים המחלקות הופכות לכל כך גדולות שאנחנו כבר לא יכולים לזכור את הפרטים שלהם.
ניווט בקוד מאט, ואנחנו צריכים לסרוק את כל המחלקות או אפילו תוכנית שלמה כדי למצוא דברים ספציפיים.
מספר האובייקטים בתוכנית מציף את הזיכרון, ואנחנו מרגישים איבוד שליטה על הקוד.
אם מחלקה עושה יותר מדיי דברים, ואנחנו רוצים להוסיף או לשנות חלקים בקוד אנחנו מסתכנים בשבירת חלקים אחרים בתוכנית.

Open/Closed Principle
הרעיון המרכזי של עיקרון זה הוא לשמור על קוד קיים מלהישבר כאשר אנחנו מיישמים תכונות חדשות.
במקום לשנות את הקוד של המחלקה ישירות אנחנו יכולים ליצור תת מחלקה ולעקוף חלקים ממנה ולשנות מקרים בהם אנחנו רוצים התנהגות אחרת וככה לא לשבור אף קוד קיים של המחלקה המקורית.
כמובן שבמקרה שיש באג במחלקה המקורית עלינו לתקן אותו ולא לעקוף עם תת מחלקה.



Liskov Substitution
כאשר אנחנו מרחיבים מחלקה, עלינו לזכור שאנחנו צריכים להיות מסוגלים להעביר אובייקטים של התת-מחלקה במקום אובייקטים של מחלקת האב מבלי לשבור את קוד הלקוח.
המשמעות היא שתת המחלקה צריכה להישאר תואמת להתנהגות של מחלקת האב \ super class.
כאשר אנחנו עושים override לפונקציה, עלינו להרחיב את ההתנהגות הבסיסית המקום להחליף אותה במשהו אחר לגמרי.
עקרון ההחלפה הוא קבוצה של בדיקות שעוזרות לחזות האם תת מחלקה נשארת תואמת לקוד שהיה מסוגל לעבוד עם אובייקטים של מחלקת האב \ מחלקת העל.
העיקרון הזה הוא קריטי בעת פיתוח Libraries או Frameworks מכיוון שהמחלקות שלנו ישמשו אנשים אחרים שאנחנו לא יכולים לגשת ישירות או לשנות את הקוד שלהם.
בניגוד לעקרונות עיצוב אחרים הפתוחים לפירוש, לעקרון ההחלפה יש מערכת פורמלית למחלקות ובמיוחד לפונקציות.

סוגי פרמטרים בפונקציה של תת-מחלקה צריכים להתאים או להיות מופשטים יותר מסוגי הפרמטרים בפונקציה של מחלקת העל
פונקציה בתת מחלקה לא צריכה לזרוק אקספשנים ששיטת הבסיס לא צפויה לזרוק.


Interface Segregation
אין להכריח לקוחות להיות תלויים בשיטות שהם לא צריכים להשתמש.
נסו להפוך את הממשקים לצרים מספיק כדי שהצרכן של הקוד לא יצטרך ליישם התנהגויות שהוא לא צריך.
על פי עקרון הפרדת הממשק, אנחנו צריכים לפרק ממשקים גדולים ליחידות יותר גרעיניות וספציפיות.
הצרכן של הקוד צריך ליישם רק את השיטות שהוא באמת צריך.
אחרת כל שינוי לממשק ישבור את קוד הצרכן בשיטות שאינו משתמש.
אין צורך לדחוס טונות של שיטות לא קשורות לממשק אחד, הורשה לא מגבילה את מספר הממשקים שמחלקה יכולה ליישם באותו זמן.


Dependency Inversion
מחלקות ברמה גבוהה לא צריכות להיות תלויות במחלקות ברמה נמוכה.
שתיהן צריכות להיות תלויות בהפשטות, הפשטות לא צריכות להיות תלויות בפרטים, הפרטים צריכים להיות תלויים בהפשטות.
מחלקות ברמה הנמוכה - מיישמות פעולות בסיסיות כגון עבודה עם דיסק, העברת נתונים ברשת, התחברות לממסד נתונים וכו'.
מחלקות ברמה הגבוהה - מכילות היגיון עסקי מורכב שמכוון מחלקות ברמה נמוכה לעשות משהו.

לפעמים אנחנו מעצבים קודם מחלקות ברמה נמוכה ואחר כך מתחילים לעבוד על הרמה הגבוהה.
זה נפוץ מאוד כאשר אתה מתחיל לפתח אב טיפוס על מערכת חדשה, ואתה עדיין לא בטוח מה אפשרי ברמה הגבוהה כי דברים ברמה הנמוכה עדיין לא מיושמים או ברורים, או במקרים של הוספת התנהגויות חדשות.
גישה זאת הופכת אותנו לתלויים במחלקות פרימיטיביות.

עקרון היפוך התלות מציע לשנות את כיוון התלות הזה.
